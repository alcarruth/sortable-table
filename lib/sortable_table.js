// Generated by CoffeeScript 2.5.1
(function() {
  //!/usr/bin/env coffee

  var Sortable_Table, Sortable_Table_Body, Sortable_Table_Header, deep, document, normal_sort;

  deep = require('deep');

  if (typeof window !== "undefined" && window !== null) {
    document = window.document;
  }

  normal_sort = function(spec) {
    var column, direction;
    ({column, direction} = spec);
    return function(a, b) {
      if (direction === 'ascending') {
        [a, b] = [b, a];
      }
      if (a[column] < b[column]) {
        return 1;
      }
      if (a[column] > b[column]) {
        return -1;
      }
      return 0;
    };
  };

  Sortable_Table = class Sortable_Table {
    constructor(data, columns) {
      var column, i, len, ref;
      this.sort_data = this.sort_data.bind(this);
      // creates and installs new table element
      this.update = this.update.bind(this);
      this.highlight = this.highlight.bind(this);
      this.add_column = this.add_column.bind(this);
      this.handle_click = this.handle_click.bind(this);
      this.columns = columns;
      this.data = deep.copy(data);
      this.elt = document.createElement('table');
      this.elt.setAttribute('id', this.id);
      this.elt.setAttribute('class', 'sortable-table');
      this.thead = new Sortable_Table_Header(this);
      this.tbody = new Sortable_Table_Body(this);
      this.elt.appendChild(this.thead.elt);
      this.elt.appendChild(this.tbody.elt);
      this.defaults = {};
      ref = this.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        this.defaults[column.key] = column.sort_order;
      }
      this.current_sort = {
        column: null,
        direction: null
      };
    }

    async sort_data(spec) {
      var data, i, len, rank, row;
      data = (await this.data);
      data.sort(normal_sort(spec));
      rank = 1;
      for (i = 0, len = data.length; i < len; i++) {
        row = data[i];
        row.rank = rank++;
      }
      this.current_sort = spec;
      return this.update();
    }

    update() {
      var tbody;
      // create new <tbody> element from current data
      tbody = new Sortable_Table_Body(this);
      this.tbody.elt.replaceWith(tbody.elt);
      this.tbody = tbody;
      return this.highlight(this.current_sort.column);
    }

    highlight(key) {
      var className, i, j, len, len1, ref, ref1, results, td, th;
      className = key.replace(/_/g, '-');
      ref = this.thead.elt.getElementsByClassName('column-heading');
      for (i = 0, len = ref.length; i < len; i++) {
        th = ref[i];
        th.classList.remove('highlight');
      }
      ref1 = this.elt.getElementsByClassName(className);
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        td = ref1[j];
        results.push(td.classList.add('highlight'));
      }
      return results;
    }

    add_column(key, spec) {
      spec.key = key;
      return this.columns[key] = spec;
    }

    handle_click(column) {
      var defalt_order, direction;
      defalt_order = this.defaults[column];
      if (defalt_order !== 'none') {
        if (this.current_sort.column === column) {
          if (this.current_sort.direction === 'ascending') {
            direction = 'descending';
          } else {
            direction = 'ascending';
          }
        } else {
          direction = defalt_order;
        }
        return this.sort_data({column, direction});
      }
    }

  };

  Sortable_Table_Header = class Sortable_Table_Header {
    constructor(table) {
      var classes, column, i, len, ref, th;
      this.table = table;
      this.elt = document.createElement('thead');
      this.elt.setAttribute('class', 'sortable-table-header');
      this.tr = document.createElement('tr');
      this.elt.setAttribute('id', 'table-header');
      ref = this.table.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        th = document.createElement('th');
        classes = column.classes.concat(['column-heading']);
        th.setAttribute('class', classes.join(' '));
        th.innerText = column.heading_text;
        th.onclick = ((key) => {
          return () => {
            return this.table.handle_click(key);
          };
        })(column.key);
        if (column.key !== 'rank') {
          th.onmouseover = (function(th) {
            return function() {
              return th.classList.add('mouseover');
            };
          })(th);
          th.onmouseout = (function(th) {
            return function() {
              return th.classList.remove('mouseover');
            };
          })(th);
        }
        this.tr.appendChild(th);
      }
      this.elt.appendChild(this.tr);
    }

  };

  Sortable_Table_Body = class Sortable_Table_Body {
    constructor(table) {
      var classes, i, j, len, len1, obj, ref, ref1, spec, td, tr;
      this.table = table;
      this.elt = document.createElement('tbody');
      this.elt.setAttribute('class', 'sortable-table-body');
      ref = this.table.data;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        tr = document.createElement('tr');
        tr.setAttribute('class', 'sortable-table-row');
        ref1 = this.table.columns;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          spec = ref1[j];
          td = document.createElement('td');
          classes = spec.classes.concat(['column-data']);
          td.setAttribute('class', spec.classes.join(' '));
          td.innerText = obj[spec.key];
          tr.appendChild(td);
        }
        this.elt.appendChild(tr);
      }
    }

  };

  exports.Sortable_Table = Sortable_Table;

}).call(this);
