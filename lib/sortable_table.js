// Generated by CoffeeScript 2.5.1
(function() {
  //!/usr/bin/env coffee

  var Sortable_Table, Sortable_Table_Body, Sortable_Table_Header, deep, document, normal_sort, number_sort;

  deep = require('deep');

  if (typeof window !== "undefined" && window !== null) {
    document = window.document;
  }

  normal_sort = function(spec) {
    var column, direction;
    ({column, direction} = spec);
    return function(a, b) {
      if (direction === 'ascending') {
        [a, b] = [b, a];
      }
      if (a[column] < b[column]) {
        return 1;
      }
      if (a[column] > b[column]) {
        return -1;
      }
      return 0;
    };
  };

  number_sort = function(spec) {
    var sort;
    sort = normal_sort(spec);
    return function(a, b) {
      return sort(Number(a), Number(b));
    };
  };

  Sortable_Table = class Sortable_Table {
    constructor(data, columns) {
      var column, i, len, ref;
      // method @sort_data({ column, direction })
      // column: the column to sort
      // direction: either 'ascending' or 'descending'

      this.sort_data = this.sort_data.bind(this);
      // method @update()
      // creates and installs new table element

      this.update = this.update.bind(this);
      // method @highlight()
      // arg: key : column key

      this.highlight = this.highlight.bind(this);
      // method @add_column(key, spec)

      this.add_column = this.add_column.bind(this);
      // method @handle_click()

      this.handle_click = this.handle_click.bind(this);
      this.columns = columns;
      this.data = deep.copy(data);
      this.elt = document.createElement('table');
      this.elt.setAttribute('id', this.id);
      this.elt.setAttribute('class', 'sortable-table');
      this.thead = new Sortable_Table_Header(this);
      this.tbody = new Sortable_Table_Body(this);
      this.elt.appendChild(this.thead.elt);
      this.elt.appendChild(this.tbody.elt);
      this.defaults = {};
      ref = this.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        this.defaults[column.key] = column.sort_order;
      }
      this.current_sort = {
        column: null,
        direction: null
      };
    }

    async sort_data(spec) {
      var data, i, len, rank, row;
      console.log(`sort_data(${spec})`);
      data = (await this.data);
      data.sort(number_sort(spec));
      rank = 1;
      for (i = 0, len = data.length; i < len; i++) {
        row = data[i];
        row.rank = rank++;
      }
      this.current_sort = spec;
      return this.update();
    }

    update() {
      var tbody;
      // create new <tbody> element from current data
      tbody = new Sortable_Table_Body(this);
      this.tbody.elt.replaceWith(tbody.elt);
      this.tbody = tbody;
      return this.highlight(this.current_sort.column);
    }

    highlight(key) {
      var className, i, j, len, len1, ref, ref1, results, td, th;
      className = key.replace(/_/g, '-');
      ref = this.thead.elt.getElementsByClassName('column-heading');
      for (i = 0, len = ref.length; i < len; i++) {
        th = ref[i];
        th.classList.remove('highlight');
      }
      ref1 = this.elt.getElementsByClassName(className);
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        td = ref1[j];
        results.push(td.classList.add('highlight'));
      }
      return results;
    }

    add_column(key, spec) {
      spec.key = key;
      return this.columns[key] = spec;
    }

    handle_click(column) {
      var defalt_order, direction;
      defalt_order = this.defaults[column];
      if (defalt_order !== 'none') {
        if (this.current_sort.column === column) {
          if (this.current_sort.direction === 'ascending') {
            direction = 'descending';
          } else {
            direction = 'ascending';
          }
        } else {
          direction = defalt_order;
        }
        return this.sort_data({column, direction});
      }
    }

  };

  Sortable_Table_Header = class Sortable_Table_Header {
    constructor(table) {
      var classes, column, i, len, ref, th;
      this.handle_click = this.handle_click.bind(this);
      this.table = table;
      this.elt = document.createElement('thead');
      this.elt.setAttribute('class', 'sortable-table-header');
      this.tr = document.createElement('tr');
      this.elt.setAttribute('id', 'table-header');
      ref = this.table.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        th = document.createElement('th');
        classes = column.classes.concat(['column-heading']);
        th.setAttribute('class', classes.join(' '));
        th.innerText = column.heading_text;
        th.onclick = this.handle_click(column.key);
        if (column.key !== 'rank') {
          th.onmouseover = this.handle_mouseover(th);
          th.onmouseout = this.handle_mouseout(th);
        }
        this.tr.appendChild(th);
      }
      this.elt.appendChild(this.tr);
    }

    handle_mouseover(th) {
      return function() {
        return th.classList.add('mouseover');
      };
    }

    handle_mouseout(th) {
      return function() {
        return th.classList.remove('mouseover');
      };
    }

    handle_click(key) {
      return () => {
        return this.table.handle_click(key);
      };
    }

  };

  Sortable_Table_Body = class Sortable_Table_Body {
    constructor(table) {
      var classes, i, j, len, len1, obj, ref, ref1, spec, td, tr;
      this.table = table;
      this.elt = document.createElement('tbody');
      this.elt.setAttribute('class', 'sortable-table-body');
      ref = this.table.data;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        tr = document.createElement('tr');
        tr.setAttribute('class', 'sortable-table-row');
        ref1 = this.table.columns;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          spec = ref1[j];
          td = document.createElement('td');
          classes = spec.classes.concat(['column-data']);
          td.setAttribute('class', spec.classes.join(' '));
          td.innerText = obj[spec.key];
          tr.appendChild(td);
        }
        this.elt.appendChild(tr);
      }
    }

  };

  exports.Sortable_Table = Sortable_Table;

}).call(this);
